<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>posts on Lukas Blog</title>
    <link>https://blog.lukas.re/post/</link>
    <description>Recent content in posts on Lukas Blog</description>
    <generator>Hugo 0.138.0</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 29 Aug 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://blog.lukas.re/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tips to Bypass WAFs</title>
      <link>https://blog.lukas.re/post/bypass-waf/</link>
      <pubDate>Fri, 29 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://blog.lukas.re/post/bypass-waf/</guid>
      <description>&lt;center&gt;&lt;img src=&#34;https://blog.lukas.re/images/bypass-waf/image.png&#34; width=500px&gt;&lt;/center&gt;&#xA;&lt;p&gt;When conducting a web security audit, it is common to encounter a WAF (Web Application Firewall), a security layer designed to detect and block exploitation attempts. While this protection adds security to the application, it can also significantly hinder the auditor’s work, preventing the validation of the real impact of certain findings.&lt;/p&gt;&#xA;&lt;p&gt;In this post, I’ll share some of the tricks and techniques I use when auditing applications protected by a WAF, but before diving into that, it’s important to understand what a WAF is, how it works, and its limitations.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-a-waf-and-how-does-it-work&#34;&gt;what is a waf and how does it work?&lt;/h2&gt;&#xA;&lt;p&gt;A WAF (Web Application Firewall) is a security system that acts as an intermediary between the client and the web application, analyzing HTTP/HTTPS traffic to detect and block malicious requests. Its main purpose is to protect against common attacks such as SQL Injection, Cross-Site Scripting (XSS), Remote File Inclusion (RFI), and other exploitation vectors described in the OWASP Top 10. Unlike a traditional firewall, which filters packets at the network or transport layers, a WAF operates at the application layer (Layer 7 of the OSI model), allowing it to thoroughly inspect the content of requests and responses.&lt;/p&gt;&#xA;&lt;p&gt;The operation of a WAF is based on applying security rules and policies that identify suspicious patterns in web requests. These rules may follow a blacklist approach (blocking known malicious traffic) or a whitelist approach (only allowing trusted traffic). Many modern WAFs leverage machine learning and behavioral analysis to detect anomalies that do not match previously known patterns. Depending on its configuration, a WAF can run in detection mode (monitoring) or prevention mode (blocking), making it a key component in the defense-in-depth strategy for Internet-exposed applications.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tip-1-use-security-trails-to-view-historical-ip-addresses&#34;&gt;tip 1: use security trails to view historical ip addresses.&lt;/h2&gt;&#xA;&lt;p&gt;An initial technique when auditing applications protected by a WAF is to investigate the underlying infrastructure. For this, SecurityTrails can be used—a platform that provides historical domain information, DNS records, IP addresses, and other infrastructure data. By entering the domain of a WAF-protected website, it is possible that some historical IP records reveal the real server IP, which can be useful for understanding the site’s architecture and planning further tests, always within a legal and authorized scope.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;Below we can see an image showing where we need to go when entering the domain&lt;/em&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;center&gt;&lt;img src=&#34;https://blog.lukas.re/images/bypass-waf/image2.png&#34; width=750px&gt;&lt;/center&gt;&#xA;&lt;h2 id=&#34;tip-2-exploiting-the-maximum-analysis-limit-of-wafs&#34;&gt;tip 2: exploiting the maximum analysis limit of WAFs.&lt;/h2&gt;&#xA;&lt;p&gt;From my experience, this technique works intermittently, as it depends on the specific WAF implementation. Most WAFs analyze requests only up to a maximum size limit; when the request contains too much data, the WAF does not fully inspect it and allows the request to pass.&lt;/p&gt;&#xA;&lt;p&gt;For example, in a post by &lt;a href=&#34;https://x.com/k_firsov/status/1937084844174934025&#34;&gt;@k_firsov&lt;/a&gt;, it is shown how he managed to bypass Cloudflare Enterprise, whose WAF inspects requests up to 128 KB. This allows that if we inject a payload that would normally be detected, we can pad the request with extra data to increase its size, causing the WAF to miss it and letting the request pass undetected.&lt;/p&gt;&#xA;&lt;p&gt;For this technique, you can use the Burp Suite extension &lt;a href=&#34;https://github.com/assetnote/nowafpls&#34;&gt;nowafpls&lt;/a&gt;, which allows adding extra data to a request to increase its size. The same repository also includes a PoC (Proof of Concept) demonstrating how to bypass an Akamai WAF.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;this video was extracted from the repository.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;center&gt;&lt;video width=&#34;640&#34; height=&#34;360&#34; controls&gt;&lt;source src=&#34;https://blog.lukas.re/images/bypass-waf/328069847-dad77c3a-d550-4e5d-894d-027256137148.mp4&#34; type=&#34;video/mp4&#34;&gt;&lt;/video&gt;&lt;/center&gt;&#xA;&lt;h2 id=&#34;tip-3-create-the-payload-manually&#34;&gt;tip 3: create the payload manually&lt;/h2&gt;&#xA;&lt;p&gt;The third tip involves designing and building the payload manually, rather than relying solely on automated tools. This technique is the most challenging, as it requires a deep understanding of the application’s behavior, the structure of requests, and the specific rules enforced by the WAF. By creating the payload manually, it is possible to experiment with different formats, encodings, and patterns to attempt evasion of the security protection.&lt;/p&gt;&#xA;&lt;p&gt;However, it is important to note that some vulnerabilities may be nearly impossible to exploit, even using advanced manual techniques. The success of this approach depends on the auditor’s creativity and detailed analysis of both the WAF and the application, as well as the ability to innovate by combining multiple evasion strategies.&lt;/p&gt;&#xA;&lt;h2 id=&#34;conclusion&#34;&gt;conclusion&lt;/h2&gt;&#xA;&lt;p&gt;bypassing a WAF is not an easy task. I created this post with the intention of giving readers some practical techniques and strategies that can be used when facing a security audit where the application is protected by a WAF. Although every WAF is different and not all vulnerabilities will be exploitable, these techniques provide a solid starting point for planning more advanced testing and analysis.&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>How to set up your Android Pentesting environment</title>
      <link>https://blog.lukas.re/post/set-up-your-android-pentesting-environment/</link>
      <pubDate>Mon, 03 Feb 2025 00:00:00 +0000</pubDate>
      <guid>https://blog.lukas.re/post/set-up-your-android-pentesting-environment/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;As cybersecurity consultants, it&amp;rsquo;s pretty common to come across Android apps that need to be audited. In this short post, I’ll show you a quick and easy way to set up your own lab to make things smoother. I’ll also share some tips on how I usually approach Android app pentesting and what I like to focus on during an assessment.&lt;/p&gt;&#xA;&lt;p&gt;A bit of theory never hurts, so here we go: First, it&amp;rsquo;s important to understand that Android applications come in .apk format. This format is a variation of Java’s .jar files and is used to package and distribute components for Android devices. Basically, an APK is just a compressed ZIP file with a different extension, which means it can be opened and inspected using any archive tool — something we’ll look at later on.&lt;/p&gt;&#xA;&lt;p&gt;This basic understanding of APK structure will come in handy as we start interacting with real applications, modifying their behavior, and inspecting their logic. Before we get to that point, though, we need to make sure our environment is properly configured.&lt;/p&gt;&#xA;&lt;h2 id=&#34;create-environment&#34;&gt;Create environment&lt;/h2&gt;&#xA;&lt;p&gt;To set up our Android pentesting lab, we need to have the following tools installed:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Genymotion&lt;/li&gt;&#xA;&lt;li&gt;Frida&lt;/li&gt;&#xA;&lt;li&gt;Burp Suite&lt;/li&gt;&#xA;&lt;li&gt;JADX&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Each of these tools plays a key role during the assessment process. Genymotion is an Android emulator that allows us to run virtual devices for testing in a controlled environment — it&amp;rsquo;s fast, flexible, and supports root access. Frida is a powerful dynamic instrumentation toolkit that lets us hook into running processes, modify app behavior on the fly, and bypass security checks like root or SSL pinning. Burp Suite acts as our intercepting proxy, enabling us to analyze and manipulate HTTP/HTTPS traffic between the app and backend services. Finally, JADX is a decompiler that allows us to convert APKs into readable Java code, making it easier to understand the app’s logic and look for hardcoded secrets, insecure API usage, or potential vulnerabilities&lt;/p&gt;&#xA;&lt;p&gt;First of all, we’re going to create two virtual devices in Genymotion — one running Android 11 and another running Android 13.0 (which is currently the highest version available in Genymotion). The reason for this setup is that, due to a recent update, Genymotion only provides root access up to Android 11. For versions above that, root access is no longer available.&lt;/p&gt;&#xA;&lt;center&gt;&lt;img src=&#34;https://i.postimg.cc/VsjgpTBy/image.png&#34;/&gt;&lt;/center&gt;&#xA;&lt;p&gt;Personally, I use the Android 11 device most of the time, since it allows me to hook and test apps freely. However, when I come across an app with strong anti-root protections that I can&amp;rsquo;t bypass easily, I switch to the Android 13.0 device to continue the analysis without root interference.&lt;/p&gt;&#xA;&lt;p&gt;Let’s start by booting up the Android 11 virtual device and opening Burp Suite. Using the following commands, we’ll extract the Burp certificate, install it on the device, and route all traffic through the proxy.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Make sure the Burp proxy listener is configured to bind to all interfaces (*).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;pre&gt;&lt;font color=&#34;#CC0000&#34;&gt;&lt;b&gt;$&lt;/b&gt;&lt;/font&gt; curl localhost:8080/cert -o cert.der&#xA;&lt;font color=&#34;#CC0000&#34;&gt;&lt;b&gt;$&lt;/b&gt;&lt;/font&gt; openssl x509 -inform der -in cert.der -out cert.pem&#xA;&lt;font color=&#34;#CC0000&#34;&gt;&lt;b&gt;$&lt;/b&gt;&lt;/font&gt; openssl x509 -inform PEM -subject_hash_old -in certificado.pem | head -1&#xA;&lt;font color=&#34;#CC0000&#34;&gt;&lt;b&gt;$&lt;/b&gt;&lt;/font&gt; mv cert.pem 9a5ba575.0&#xA;&lt;font color=&#34;#CC0000&#34;&gt;&lt;b&gt;$&lt;/b&gt;&lt;/font&gt; adb shell&#xA;vbox86p:/ # su&#xA;1|:/ # mount -o remount,rw /                                                   &#xA;:/ # exit&#xA;vbox86p:/ # exit&#xA;&lt;font color=&#34;#CC0000&#34;&gt;&lt;b&gt;$&lt;/b&gt;&lt;/font&gt; adb push 9a5ba575.0 /system/etc/security/cacerts/&#xA;&lt;/pre&gt;&#xA;&lt;p&gt;In this step, we gain root access to the Android emulator using adb shell and su, then remount the root filesystem with read/write permissions (mount -o remount,rw /) to allow modifications. After that, we use adb push to copy the Burp Suite certificate (9a5ba575.0) into the system&amp;rsquo;s trusted CA store located at /system/etc/security/cacerts/, enabling the device to trust our proxy and properly intercept HTTPS traffic.&lt;/p&gt;&#xA;&lt;p&gt;Now we need to set up the proxy on the Android device. To do that, we first need to get our local IP address — you can use &lt;code&gt;ifconfig&lt;/code&gt; or &lt;code&gt;ip a&lt;/code&gt; for that. Once you have your local IP, run the following command to configure the proxy on the emulator:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;font color=&#34;#CC0000&#34;&gt;&lt;b&gt;$&lt;/b&gt;&lt;/font&gt; adb shell settings put global http_proxy 192.168.1.82:8080&lt;/pre&gt;&#xA;&lt;p&gt;This tells the Android system to route all HTTP and HTTPS traffic through the specified proxy — in this case, Burp Suite running on port 8080 of your local machine. Now, if you open a browser on the device and search for anything on Google, you should see the traffic being intercepted in Burp Suite.&lt;/p&gt;&#xA;&lt;center&gt;&lt;img src=&#34;https://i.postimg.cc/XJ5RT8x2/image.png&#34;/&gt;&lt;/center&gt;&#xA;&lt;h2 id=&#34;set-frida&#34;&gt;Set Frida&lt;/h2&gt;&#xA;&lt;p&gt;If we’re going to audit an app that doesn’t implement SSL pinning or root detection, we can start right away with the setup we just configured. All we need to do is install the app and start analyzing the network traffic.&lt;/p&gt;&#xA;&lt;p&gt;But things won’t always be smooth — more often than not, we’ll run into apps with protection mechanisms like SSL pinning, root detection, and more. That’s where Frida comes in.&lt;/p&gt;&#xA;&lt;p&gt;Frida is a dynamic instrumentation toolkit that lets us inject JavaScript into running processes, giving us the ability to bypass or modify app behavior at runtime. With Frida, we can hook into specific functions, disable root checks, bypass SSL pinning, monitor internal function calls, and even modify return values — all without needing to recompile the APK. It&amp;rsquo;s one of the most powerful tools in mobile app pentesting, especially when dealing with hardened apps.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;If you’re not familiar with the concepts of SSL pinning and root detection, I recommend checking out these two articles: &lt;a href=&#34;https://www.indusface.com/learning/what-is-ssl-pinning-a-quick-walk-through/1&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;https://www.security-garage.com/es/introduccion-al-hacking/bypassing-android-app-security-in-3-2-1-pwned-defeating-root-control-detection&#34;&gt;2&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;To use Frida on the Android device, we need to install &lt;a href=&#34;https://github.com/frida/frida/releases/tag/17.2.14&#34;&gt;frida-server&lt;/a&gt; on the emulator or physical device. This binary must match the architecture of the Android system (usually x86 for Genymotion or arm64 for real devices). Once downloaded, we push it to the device and run it in the background with the following commands:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;font color=&#34;#CC0000&#34;&gt;&lt;b&gt;$&lt;/b&gt;&lt;/font&gt; adb push frida-server /data/local/tmp/&#xA;&lt;font color=&#34;#CC0000&#34;&gt;&lt;b&gt;$&lt;/b&gt;&lt;/font&gt; adb shell &amp;quot;chmod +x &amp;apos;/data/local/tmp/frida-server&amp;apos;&amp;quot;&#xA;&lt;font color=&#34;#CC0000&#34;&gt;&lt;b&gt;$&lt;/b&gt;&lt;/font&gt; adb shell &amp;quot;su -c &amp;apos;/data/local/tmp/frida-server &amp;amp;&amp;apos;&amp;quot;&lt;/pre&gt;&#xA;&lt;p&gt;This sets the correct permissions and runs Frida with root privileges in the background, allowing us to start injecting scripts into apps from our host machine using the Frida CLI or Python bindings.&lt;/p&gt;&#xA;&lt;p&gt;Once Frida is up and running on the phone, we can start using it to hook and modify the behavior of applications in real time. As an example, we&amp;rsquo;ll bypass the root detection protection of an app called fridaen45minutos. This application was created by some colleagues specifically for a talk, and it includes basic checks to prevent execution on rooted devices. You can download it &lt;a href=&#34;https://github.com/TaconeoMental/frida-en-45-minutos&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;If we install the app on our phone and try to launch it, we’ll quickly notice that it doesn’t allow us to proceed — that’s because the device is rooted. The app detects the root status and immediately blocks access as a security measure. This behavior is exactly what we’ll be targeting and bypassing with Frida.&lt;/p&gt;&#xA;&lt;center&gt;&lt;img src=&#34;https://i.postimg.cc/43BwG2cj/imagen.png&#34;/&gt;&lt;/center&gt;&#xA;&lt;h2 id=&#34;evasion-of-anti-root-control&#34;&gt;Evasion of anti-root control&lt;/h2&gt;&#xA;&lt;p&gt;Now we’re going to use a Frida script designed to bypass the root detection mechanisms implemented in the application. Once we hook into the app’s process and inject the script, Frida will override the methods responsible for performing root checks at runtime, effectively disabling the protection. This allows us to run and interact with the application on a rooted device without being blocked.&lt;/p&gt;&#xA;&lt;p&gt;The script is included in the repository of the &lt;a href=&#34;https://github.com/TaconeoMental/frida-en-45-minutos/tree/main&#34;&gt;frida-en-45-minutos&lt;/a&gt; application, so you can find it there and use it directly:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;Java&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;available&lt;/span&gt;){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Java&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;perform&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rootCheckerClass&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Java&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;use&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;com.nivel4.RootChecker.rootChecker&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;rootCheckerClass&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;checkSu&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;implementation&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;checkSu returned&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;checkSu&lt;/span&gt;());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;rootCheckerClass&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;testKeys&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;implementation&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;testKeys returned&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;testKeys&lt;/span&gt;());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;rootCheckerClass&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;checkPackages&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;implementation&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;checkPackages returned&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;checkPackages&lt;/span&gt;());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    })&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To find the app&amp;rsquo;s identifier (package name), we can run the following command:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;font color=&#34;#CC0000&#34;&gt;&lt;b&gt;$&lt;/b&gt;&lt;/font&gt; frida-ps -Uai&#xA; PID  Name                  Identifier                      &#xA;----  --------------------  --------------------------------&#xA;6429  Files                 com.android.documentsui         &#xA;6366  Google Play Store     com.android.vending             &#xA;3556  Phone                 com.android.dialer              &#xA;7039  fridaen45minutos      com.nivel4.fridaen45minutos     &#xA;   -  Amaze                 com.amaze.filemanager           &#xA;   -  Aptoide               cm.aptoide.pt                   &#xA;   -  Calendar              com.android.calendar            &#xA;   -  Camera                com.android.camera2             &#xA;   -  Clock                 com.android.deskclock           &#xA;   -  Contacts              com.android.contacts            &#xA;   -  Custom Locale         com.android.customlocale2       &#xA;   -  Dev Tools             com.android.development         &#xA;   -  Development Settings  com.android.development_settings&#xA;   -  Gallery               com.android.gallery3d           &#xA;   -  JokesPhone            com.cashitapp.app.jokesphone    &#xA;   -  Messaging             com.android.messaging           &#xA;   -  Neatpagos             com.neat.mobileappprod          &#xA;   -  Search                com.android.quicksearchbox      &#xA;   -  Settings              com.android.settings            &#xA;   -  Superuser             com.genymotion.superuser        &#xA;   -  WebView Shell         org.chromium.webview_shell&lt;/pre&gt;&#xA;&lt;p&gt;Once we have the correct identifier (in this case, com.nivel4.fridaen45minutos), we can load the script into the running app by executing:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;font color=&#34;#CC0000&#34;&gt;&lt;b&gt;$&lt;/b&gt;&lt;/font&gt; frida -U -f com.nivel4.fridaen45minutos -l antiroot.js&#xA;     ____&#xA;    / _  |   Frida 16.5.2 - A world-class dynamic instrumentation toolkit&#xA;   | (_| |&#xA;    &amp;gt; _  |   Commands:&#xA;   /_/ |_|       help      -&amp;gt; Displays the help system&#xA;   . . . .       object?   -&amp;gt; Display information about &amp;apos;object&amp;apos;&#xA;   . . . .       exit/quit -&amp;gt; Exit&#xA;   . . . .&#xA;   . . . .   More info at https://frida.re/docs/home/&#xA;   . . . .&#xA;   . . . .   Connected to Pixel (id=127.0.0.1:6555)&#xA;&lt;b&gt;Spawned `com.nivel4.fridaen45minutos`. Resuming main thread!&lt;/b&gt;            &#xA;[Pixel::com.nivel4.fridaen45minutos ]-&amp;gt;&#xA;checkSu returned true&#xA;checkPackages returned true&#xA;testKeys returned true&lt;/pre&gt;&#xA;&lt;p&gt;This will inject the script and hook the necessary functions to disable the app’s root detection. After that, if we launch the app on a rooted device, it will no longer block access. This confirms that the anti-root bypass was successful, allowing us to interact with the application freely despite the device being rooted.&lt;/p&gt;&#xA;&lt;center&gt;&lt;img src=&#34;https://i.postimg.cc/02YB3ft1/imagen.png&#34;&gt;&lt;/center&gt;&#xA;&lt;p&gt;In the previous example, we saw how Frida combined with a custom script can effectively bypass the root detection mechanisms of an application. This approach allows security testers to analyze and interact with apps that would otherwise refuse to run on rooted devices, opening the door to deeper inspection and testing.&lt;/p&gt;&#xA;&lt;h2 id=&#34;reverse-engineering&#34;&gt;Reverse Engineering&lt;/h2&gt;&#xA;&lt;p&gt;If we need to perform reverse engineering on the APK, one of the most useful tools is Jadx. After installing it, you’ll find a binary called jadx-gui, which launches the graphical interface of the tool — making it easier to explore the app’s internals visually.&lt;/p&gt;&#xA;&lt;p&gt;To get started, simply open jadx-gui, click on &amp;ldquo;File&amp;rdquo; &amp;gt; &amp;ldquo;Open&amp;rdquo;, and select the APK you want to analyze. Jadx will automatically decompile the DEX (Dalvik Executable) files inside the APK and present you with a Java-like source code view. You’ll be able to browse through the app’s package structure, classes, methods, and resources like AndroidManifest.xml, layouts, and strings.&lt;/p&gt;&#xA;&lt;center&gt;&lt;img src=&#34;https://i.postimg.cc/PxPXN9h2/image.png&#34;&gt;&lt;/center&gt;&#xA;&lt;p&gt;This is extremely useful for understanding how the app works under the hood, identifying potential attack surfaces (such as hardcoded API keys, exposed components, insecure logic), and mapping out where you might want to hook or patch with tools like Frida.&lt;/p&gt;&#xA;&lt;p&gt;While Jadx doesn’t produce 100% accurate Java code (since it&amp;rsquo;s decompiled from bytecode), it&amp;rsquo;s more than enough for static analysis and planning dynamic testing.&lt;/p&gt;&#xA;&lt;p&gt;In summary: We went through how to set up an environment for mobile app testing, how to configure a proxy to intercept traffic, and how to use Frida to bypass common protections when needed.&lt;/p&gt;&#xA;&lt;p&gt;Now, I’d like to share some personal tips based on my experience — things that help me perform effective analysis and find interesting vulnerabilities in a short amount of time (because let’s be honest, we rarely have unlimited time during an audit).&lt;/p&gt;&#xA;&lt;h2 id=&#34;tips&#34;&gt;Tips&lt;/h2&gt;&#xA;&lt;p&gt;The first thing I usually do is open the APK in jadx-gui and look for any exposed or leaked information — such as hardcoded API keys, credentials, internal endpoints, or file paths. Once I get a general idea of the app’s structure, I install the APK on an emulator and check if it implements security protections like SSL Pinning or Root Detection.&lt;/p&gt;&#xA;&lt;p&gt;If the app has no protections in place — lucky day! — I jump straight into the ethical hacking phase. But if those protections are present, I try to bypass them using Frida scripts. If the scripts don’t work, then it’s time to go manual — which is great for learning. If you&amp;rsquo;re interested in learning how to do it manually, I highly recommend this &lt;a href=&#34;https://www.youtube.com/watch?v=lFcmen66qe4&#34;&gt;talk&lt;/a&gt; (given by some good friends of mine — absolute pros, by the way).&lt;/p&gt;&#xA;&lt;p&gt;Once the protections are bypassed, I treat the mobile app just like I would a web application. Most mobile apps interact with backend APIs, especially when there’s a login mechanism involved, so the approach becomes very similar to classic API pentesting.&lt;/p&gt;&#xA;&lt;p&gt;In general, I focus heavily on business logic flaws, injection points, and poor client-side control of iterations, parameters, or flows. I also use multiple mobile testing checklists and guides to make sure I cover as much ground as possible and get the highest value findings in the time I have.&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>

