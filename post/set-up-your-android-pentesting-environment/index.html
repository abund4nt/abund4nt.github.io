<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Hugo 0.138.0">
    <title>Lukas Blog</title><link rel="stylesheet" href="https://blog.lukas.re/css/colors-default-dark.css">
    <link rel="stylesheet" href="https://blog.lukas.re/css/style.css">
    
</head>

    <body>
        <div class="site-content">
            <header>
                <div class="header-container">
    <div class="site-header">
        <a class="site-header" href="https://blog.lukas.re/">Lukas Blog</a>
    </div>
    <div class="site-nav">
        <nav aria-label="Site menu" class="site-nav"><a class="nav-item active first" href="/post/">posts</a><a class="nav-item last" href="/about/">about</a>
        </nav>
    </div>
</div>

            </header>
            <main class="content">
                
<article class="h-entry">
    <div class="post-metadata">
        <h1 class="post-title p-name">How to set up your Android Pentesting environment</h1>
        <p class="post-date">
            <span class="post-date">
                Published on
                <a class="u-url" href="https://blog.lukas.re/post/set-up-your-android-pentesting-environment/"><time class="dt-published" datetime="2025-02-03T00:00:00Z">February 3, 2025</time></a>
                by <img class="u-photo" alt="" src="https://blog.lukas.re/images/i.jpg"> <a class="p-author h-card" rel="author" href="https://blog.lukas.re/">Lukas Gaete</a>
            </span>
        </p>
    </div>
    <div class="post-content e-content">
        <h2 id="introduction">Introduction</h2>
<p>As cybersecurity consultants, it&rsquo;s pretty common to come across Android apps that need to be audited. In this short post, I’ll show you a quick and easy way to set up your own lab to make things smoother. I’ll also share some tips on how I usually approach Android app pentesting and what I like to focus on during an assessment.</p>
<p>A bit of theory never hurts, so here we go: First, it&rsquo;s important to understand that Android applications come in .apk format. This format is a variation of Java’s .jar files and is used to package and distribute components for Android devices. Basically, an APK is just a compressed ZIP file with a different extension, which means it can be opened and inspected using any archive tool — something we’ll look at later on.</p>
<p>This basic understanding of APK structure will come in handy as we start interacting with real applications, modifying their behavior, and inspecting their logic. Before we get to that point, though, we need to make sure our environment is properly configured.</p>
<h2 id="create-environment">Create environment</h2>
<p>To set up our Android pentesting lab, we need to have the following tools installed:</p>
<ul>
<li>Genymotion</li>
<li>Frida</li>
<li>Burp Suite</li>
<li>JADX</li>
</ul>
<p>Each of these tools plays a key role during the assessment process. Genymotion is an Android emulator that allows us to run virtual devices for testing in a controlled environment — it&rsquo;s fast, flexible, and supports root access. Frida is a powerful dynamic instrumentation toolkit that lets us hook into running processes, modify app behavior on the fly, and bypass security checks like root or SSL pinning. Burp Suite acts as our intercepting proxy, enabling us to analyze and manipulate HTTP/HTTPS traffic between the app and backend services. Finally, JADX is a decompiler that allows us to convert APKs into readable Java code, making it easier to understand the app’s logic and look for hardcoded secrets, insecure API usage, or potential vulnerabilities</p>
<p>First of all, we’re going to create two virtual devices in Genymotion — one running Android 11 and another running Android 13.0 (which is currently the highest version available in Genymotion). The reason for this setup is that, due to a recent update, Genymotion only provides root access up to Android 11. For versions above that, root access is no longer available.</p>
<center><img src="https://i.postimg.cc/VsjgpTBy/image.png"/></center>
<p>Personally, I use the Android 11 device most of the time, since it allows me to hook and test apps freely. However, when I come across an app with strong anti-root protections that I can&rsquo;t bypass easily, I switch to the Android 13.0 device to continue the analysis without root interference.</p>
<p>Let’s start by booting up the Android 11 virtual device and opening Burp Suite. Using the following commands, we’ll extract the Burp certificate, install it on the device, and route all traffic through the proxy.</p>
<blockquote>
<p>Make sure the Burp proxy listener is configured to bind to all interfaces (*).</p>
</blockquote>
<pre><font color="#CC0000"><b>$</b></font> curl localhost:8080/cert -o cert.der
<font color="#CC0000"><b>$</b></font> openssl x509 -inform der -in cert.der -out cert.pem
<font color="#CC0000"><b>$</b></font> openssl x509 -inform PEM -subject_hash_old -in certificado.pem | head -1
<font color="#CC0000"><b>$</b></font> mv cert.pem 9a5ba575.0
<font color="#CC0000"><b>$</b></font> adb shell
vbox86p:/ # su
1|:/ # mount -o remount,rw /                                                   
:/ # exit
vbox86p:/ # exit
<font color="#CC0000"><b>$</b></font> adb push 9a5ba575.0 /system/etc/security/cacerts/
</pre>
<p>In this step, we gain root access to the Android emulator using adb shell and su, then remount the root filesystem with read/write permissions (mount -o remount,rw /) to allow modifications. After that, we use adb push to copy the Burp Suite certificate (9a5ba575.0) into the system&rsquo;s trusted CA store located at /system/etc/security/cacerts/, enabling the device to trust our proxy and properly intercept HTTPS traffic.</p>
<p>Now we need to set up the proxy on the Android device. To do that, we first need to get our local IP address — you can use <code>ifconfig</code> or <code>ip a</code> for that. Once you have your local IP, run the following command to configure the proxy on the emulator:</p>
<pre><font color="#CC0000"><b>$</b></font> adb shell settings put global http_proxy 192.168.1.82:8080</pre>
<p>This tells the Android system to route all HTTP and HTTPS traffic through the specified proxy — in this case, Burp Suite running on port 8080 of your local machine. Now, if you open a browser on the device and search for anything on Google, you should see the traffic being intercepted in Burp Suite.</p>
<center><img src="https://i.postimg.cc/XJ5RT8x2/image.png"/></center>
<h2 id="set-frida">Set Frida</h2>
<p>If we’re going to audit an app that doesn’t implement SSL pinning or root detection, we can start right away with the setup we just configured. All we need to do is install the app and start analyzing the network traffic.</p>
<p>But things won’t always be smooth — more often than not, we’ll run into apps with protection mechanisms like SSL pinning, root detection, and more. That’s where Frida comes in.</p>
<p>Frida is a dynamic instrumentation toolkit that lets us inject JavaScript into running processes, giving us the ability to bypass or modify app behavior at runtime. With Frida, we can hook into specific functions, disable root checks, bypass SSL pinning, monitor internal function calls, and even modify return values — all without needing to recompile the APK. It&rsquo;s one of the most powerful tools in mobile app pentesting, especially when dealing with hardened apps.</p>
<blockquote>
<p>If you’re not familiar with the concepts of SSL pinning and root detection, I recommend checking out these two articles: <a href="https://www.indusface.com/learning/what-is-ssl-pinning-a-quick-walk-through/1">1</a>, <a href="https://www.security-garage.com/es/introduccion-al-hacking/bypassing-android-app-security-in-3-2-1-pwned-defeating-root-control-detection">2</a></p>
</blockquote>
<p>To use Frida on the Android device, we need to install <a href="https://github.com/frida/frida/releases/tag/17.2.14">frida-server</a> on the emulator or physical device. This binary must match the architecture of the Android system (usually x86 for Genymotion or arm64 for real devices). Once downloaded, we push it to the device and run it in the background with the following commands:</p>
<pre><font color="#CC0000"><b>$</b></font> adb push frida-server /data/local/tmp/
<font color="#CC0000"><b>$</b></font> adb shell &quot;chmod +x &apos;/data/local/tmp/frida-server&apos;&quot;
<font color="#CC0000"><b>$</b></font> adb shell &quot;su -c &apos;/data/local/tmp/frida-server &amp;&apos;&quot;</pre>
<p>This sets the correct permissions and runs Frida with root privileges in the background, allowing us to start injecting scripts into apps from our host machine using the Frida CLI or Python bindings.</p>
<p>Once Frida is up and running on the phone, we can start using it to hook and modify the behavior of applications in real time. As an example, we&rsquo;ll bypass the root detection protection of an app called fridaen45minutos. This application was created by some colleagues specifically for a talk, and it includes basic checks to prevent execution on rooted devices. You can download it <a href="https://github.com/TaconeoMental/frida-en-45-minutos">here</a>.</p>
<p>If we install the app on our phone and try to launch it, we’ll quickly notice that it doesn’t allow us to proceed — that’s because the device is rooted. The app detects the root status and immediately blocks access as a security measure. This behavior is exactly what we’ll be targeting and bypassing with Frida.</p>
<center><img src="https://i.postimg.cc/43BwG2cj/imagen.png"/></center>
<h2 id="evasion-of-anti-root-control">Evasion of anti-root control</h2>
<p>Now we’re going to use a Frida script designed to bypass the root detection mechanisms implemented in the application. Once we hook into the app’s process and inject the script, Frida will override the methods responsible for performing root checks at runtime, effectively disabling the protection. This allows us to run and interact with the application on a rooted device without being blocked.</p>
<p>The script is included in the repository of the <a href="https://github.com/TaconeoMental/frida-en-45-minutos/tree/main">frida-en-45-minutos</a> application, so you can find it there and use it directly:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">Java</span>.<span style="color:#a6e22e">available</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Java</span>.<span style="color:#a6e22e">perform</span>(<span style="color:#66d9ef">function</span>(){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">rootCheckerClass</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Java</span>.<span style="color:#a6e22e">use</span>(<span style="color:#e6db74">&#34;com.nivel4.RootChecker.rootChecker&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rootCheckerClass</span>.<span style="color:#a6e22e">checkSu</span>.<span style="color:#a6e22e">implementation</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;checkSu returned&#34;</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">checkSu</span>());
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rootCheckerClass</span>.<span style="color:#a6e22e">testKeys</span>.<span style="color:#a6e22e">implementation</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;testKeys returned&#34;</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">testKeys</span>());
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">rootCheckerClass</span>.<span style="color:#a6e22e">checkPackages</span>.<span style="color:#a6e22e">implementation</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#34;checkPackages returned&#34;</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">checkPackages</span>());
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To find the app&rsquo;s identifier (package name), we can run the following command:</p>
<pre><font color="#CC0000"><b>$</b></font> frida-ps -Uai
 PID  Name                  Identifier                      
----  --------------------  --------------------------------
6429  Files                 com.android.documentsui         
6366  Google Play Store     com.android.vending             
3556  Phone                 com.android.dialer              
7039  fridaen45minutos      com.nivel4.fridaen45minutos     
   -  Amaze                 com.amaze.filemanager           
   -  Aptoide               cm.aptoide.pt                   
   -  Calendar              com.android.calendar            
   -  Camera                com.android.camera2             
   -  Clock                 com.android.deskclock           
   -  Contacts              com.android.contacts            
   -  Custom Locale         com.android.customlocale2       
   -  Dev Tools             com.android.development         
   -  Development Settings  com.android.development_settings
   -  Gallery               com.android.gallery3d           
   -  JokesPhone            com.cashitapp.app.jokesphone    
   -  Messaging             com.android.messaging           
   -  Neatpagos             com.neat.mobileappprod          
   -  Search                com.android.quicksearchbox      
   -  Settings              com.android.settings            
   -  Superuser             com.genymotion.superuser        
   -  WebView Shell         org.chromium.webview_shell</pre>
<p>Once we have the correct identifier (in this case, com.nivel4.fridaen45minutos), we can load the script into the running app by executing:</p>
<pre><font color="#CC0000"><b>$</b></font> frida -U -f com.nivel4.fridaen45minutos -l antiroot.js
     ____
    / _  |   Frida 16.5.2 - A world-class dynamic instrumentation toolkit
   | (_| |
    &gt; _  |   Commands:
   /_/ |_|       help      -&gt; Displays the help system
   . . . .       object?   -&gt; Display information about &apos;object&apos;
   . . . .       exit/quit -&gt; Exit
   . . . .
   . . . .   More info at https://frida.re/docs/home/
   . . . .
   . . . .   Connected to Pixel (id=127.0.0.1:6555)
<b>Spawned `com.nivel4.fridaen45minutos`. Resuming main thread!</b>            
[Pixel::com.nivel4.fridaen45minutos ]-&gt;
checkSu returned true
checkPackages returned true
testKeys returned true</pre>
<p>This will inject the script and hook the necessary functions to disable the app’s root detection. After that, if we launch the app on a rooted device, it will no longer block access. This confirms that the anti-root bypass was successful, allowing us to interact with the application freely despite the device being rooted.</p>
<center><img src="https://i.postimg.cc/02YB3ft1/imagen.png"></center>
<p>In the previous example, we saw how Frida combined with a custom script can effectively bypass the root detection mechanisms of an application. This approach allows security testers to analyze and interact with apps that would otherwise refuse to run on rooted devices, opening the door to deeper inspection and testing.</p>
<h2 id="reverse-engineering">Reverse Engineering</h2>
<p>If we need to perform reverse engineering on the APK, one of the most useful tools is Jadx. After installing it, you’ll find a binary called jadx-gui, which launches the graphical interface of the tool — making it easier to explore the app’s internals visually.</p>
<p>To get started, simply open jadx-gui, click on &ldquo;File&rdquo; &gt; &ldquo;Open&rdquo;, and select the APK you want to analyze. Jadx will automatically decompile the DEX (Dalvik Executable) files inside the APK and present you with a Java-like source code view. You’ll be able to browse through the app’s package structure, classes, methods, and resources like AndroidManifest.xml, layouts, and strings.</p>
<center><img src="https://i.postimg.cc/PxPXN9h2/image.png"></center>
<p>This is extremely useful for understanding how the app works under the hood, identifying potential attack surfaces (such as hardcoded API keys, exposed components, insecure logic), and mapping out where you might want to hook or patch with tools like Frida.</p>
<p>While Jadx doesn’t produce 100% accurate Java code (since it&rsquo;s decompiled from bytecode), it&rsquo;s more than enough for static analysis and planning dynamic testing.</p>
<p>In summary: We went through how to set up an environment for mobile app testing, how to configure a proxy to intercept traffic, and how to use Frida to bypass common protections when needed.</p>
<p>Now, I’d like to share some personal tips based on my experience — things that help me perform effective analysis and find interesting vulnerabilities in a short amount of time (because let’s be honest, we rarely have unlimited time during an audit).</p>
<h2 id="tips">Tips</h2>
<p>The first thing I usually do is open the APK in jadx-gui and look for any exposed or leaked information — such as hardcoded API keys, credentials, internal endpoints, or file paths. Once I get a general idea of the app’s structure, I install the APK on an emulator and check if it implements security protections like SSL Pinning or Root Detection.</p>
<p>If the app has no protections in place — lucky day! — I jump straight into the ethical hacking phase. But if those protections are present, I try to bypass them using Frida scripts. If the scripts don’t work, then it’s time to go manual — which is great for learning. If you&rsquo;re interested in learning how to do it manually, I highly recommend this <a href="https://www.youtube.com/watch?v=lFcmen66qe4">talk</a> (given by some good friends of mine — absolute pros, by the way).</p>
<p>Once the protections are bypassed, I treat the mobile app just like I would a web application. Most mobile apps interact with backend APIs, especially when there’s a login mechanism involved, so the approach becomes very similar to classic API pentesting.</p>
<p>In general, I focus heavily on business logic flaws, injection points, and poor client-side control of iterations, parameters, or flows. I also use multiple mobile testing checklists and guides to make sure I cover as much ground as possible and get the highest value findings in the time I have.</p>

    </div>
</article>

            </main>
            <footer><div class="footer-container">
    <div class="h-card bio">
<p>
    <a class="u-url" href="https://blog.lukas.re/">Lukas Blog</a>
    created by <img class="u-photo" alt="" src="https://blog.lukas.re/images/i.jpg"> <span class="p-name" rel="me">Lukas Gaete</span>
        (<span class="u-pronoun">they</span>/<span class="u-pronoun">them</span> pronouns.
</p>

</div><div class="footer-text footer-right">
        <p>
            Stay focus 🧠.
        </p>
    </div></div>
<div class="h-card social">
    <a class="u-url" rel="me" aria-label="email" href="mailto:abund4nt@proton.me"><span class="social-icon" ></span></a>
<a class="u-url" rel="me" aria-label="github" href="https://github.com/abund4nt"><span class="social-icon" ></span></a>
</div>
</footer>
        </div>
    </body>
</html>